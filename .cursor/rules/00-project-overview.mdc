---
alwaysApply: true
description: 项目整体架构 - Beancount-Trans 项目规则
---

# 项目整体架构：Beancount-Trans 项目规则

## 项目结构

Beancount-Trans 是一个前后端分离的多模块项目，采用 Git Submodules 组织：

- **`Beancount-Trans-Backend/`** - Django REST API 后端（独立 Git 仓库）
- **`Beancount-Trans-Frontend/`** - Vue 3 + TypeScript 前端（独立 Git 仓库）
- **`Beancount-Trans-Docs/`** - Docusaurus 文档站点（独立 Git 仓库）
- **`Beancount-Trans-Assets/`** - 资源文件（Beancount 账本文件等，独立 Git 仓库）
- **根目录** - Docker Compose 编排、CI/CD 配置、全局配置

参考根目录 [`README.md`](mdc:README.md) 了解项目全貌和技术架构。

## 前端与后端职责划分

**所有新需求必须明确区分前端处理还是后端处理，并说明原因。** 遵循以下原则：

### 后端处理（Django REST API）

后端负责以下功能，原因说明：

- **数据持久化与业务逻辑**：数据库 CRUD、数据校验、业务规则执行（原因：保证数据一致性、安全性、可复用性）
- **用户认证与授权**：JWT 令牌生成/验证、权限检查、多因素认证（原因：安全敏感操作必须在服务端进行）
- **文件存储与管理**：文件上传、存储到 MinIO/S3、文件元数据管理（原因：需要统一存储后端、权限控制、大文件处理）
- **异步任务处理**：Celery 任务调度、批量处理、长时间运行任务（原因：避免阻塞 HTTP 请求、支持任务状态追踪）
- **AI 模型调用**：账单解析、分类识别、外部 AI 服务集成（原因：模型部署在服务端、需要访问训练数据）
- **数据统计与分析**：复杂查询、聚合计算、报表生成（原因：利用数据库性能、减少网络传输）
- **系统集成**：与 MinIO、Redis、PostgreSQL、外部 API 的交互（原因：服务间通信、基础设施抽象）
- **数据迁移与备份**：数据库迁移、批量数据操作（原因：需要直接访问数据库）

### 前端处理（Vue 3 + TypeScript）

前端负责以下功能，原因说明：

- **用户界面渲染**：页面布局、组件展示、响应式设计（原因：用户体验、浏览器端交互）
- **表单输入与校验**：用户输入、前端验证、错误提示（原因：即时反馈、减少无效请求）
- **路由与导航**：SPA 路由、页面跳转、路由守卫（原因：客户端路由、提升用户体验）
- **状态管理**：组件状态、用户偏好设置、客户端缓存（原因：减少服务器负载、离线能力）
- **UI 交互逻辑**：按钮点击、表格排序/筛选、模态框、下拉菜单（原因：纯展示层交互、无需服务器参与）
- **数据可视化**：图表展示、表格渲染、数据格式化（原因：利用浏览器渲染能力、减少服务器计算）
- **客户端缓存**：LocalStorage、SessionStorage、组件级缓存（原因：提升性能、减少重复请求）
- **文件预览与选择**：文件选择器、图片预览、CSV 表格预览（原因：浏览器原生能力、用户体验）

### 跨层协作场景

以下场景需要前后端协同，明确分工：

- **文件上传**：
  - 前端：文件选择、预览、进度显示、前端格式校验
  - 后端：接收文件、存储到对象存储、元数据入库、安全校验
  - 原因：前端负责用户体验，后端负责持久化与安全

- **实时状态查询**：
  - 前端：轮询或 WebSocket 客户端、状态展示
  - 后端：提供 REST API 或 WebSocket 服务、任务状态更新
  - 原因：前端负责展示，后端负责状态管理

- **数据展示与操作**：
  - 前端：列表展示、分页、排序、筛选 UI、操作按钮
  - 后端：提供分页 API、筛选参数处理、执行操作、返回结果
  - 原因：前后端分离架构，API 驱动

### 需求分析流程

在实现任何新功能前，必须按以下步骤分析：

1. **明确功能边界**：确定功能的输入、输出、核心逻辑
2. **职责划分**：按照上述原则判断前端/后端职责
3. **接口设计**：如果是跨层功能，明确 API 契约（请求/响应格式）
4. **说明原因**：在实现计划中说明为什么这样划分

## Git Submodule 工作流

### 初始化子模块

```bash
git submodule update --init  # 初始化所有子模块
git submodule update --init --recursive  # 递归初始化嵌套子模块
```

### 子模块开发流程

1. **在主仓库中更新子模块引用**：
   ```bash
   cd Beancount-Trans-Frontend
   git checkout main
   git pull origin main
   cd ..
   git add Beancount-Trans-Frontend
   git commit -m "chore: update frontend submodule to latest"
   ```

2. **在子模块中独立开发**：
   - 每个子模块是独立的 Git 仓库，有自己的分支、标签、提交历史
   - 在子模块目录中正常使用 Git 命令

3. **同步子模块变更**：
   - 子模块更新后，需要回到主仓库提交子模块引用更新
   - 主仓库只跟踪子模块的 commit hash，不包含子模块的实际代码

### 子模块规范

- **独立版本管理**：每个子模块维护自己的版本号（如 `CHANGELOG.md`、`package.json` 版本）
- **主仓库协调**：主仓库的 `docker-compose.yaml` 统一编排所有服务
- **CI/CD 分离**：每个子模块有自己的 `Jenkinsfile`，可以独立构建和部署

## Docker 部署架构

### 服务组成

参考根目录 [`docker-compose.yaml`](mdc:docker-compose.yaml)：

- **beancount-trans-frontend** - Nginx 静态文件服务
- **beancount-trans-backend** - Django WSGI 应用（uWSGI）
- **beancount-trans-worker** - Celery Worker（可多实例）
- **beancount-trans-beat** - Celery Beat 定时任务
- **beancount-trans-postgres** - PostgreSQL 数据库
- **beancount-trans-redis** - Redis 缓存和消息队列
- **beancount-trans-minio** - 对象存储服务
- **beancount-trans-assets** - 静态资源服务

### 卷挂载

- **`Beancount-Trans-Assets/`** → 后端容器 `/code/Beancount-Trans-Assets`：用户账本文件
- **`collectstatic/`** → 前端容器和后端容器共享：Django 静态文件
- **数据库和 Redis 数据卷**：持久化存储

### 环境变量

所有配置通过环境变量注入，参考各子模块的文档：
- 后端：`Beancount-Trans-Backend/docs/ENV_CONFIG.md`
- 根目录：`docker-compose.yaml` 中的 `environment` 部分

## 开发工作流

### 本地开发环境

1. **克隆项目**：
   ```bash
   git clone https://github.com/dhr2333/Beancount-Trans.git
   cd Beancount-Trans
   git submodule update --init
   ```

2. **前端开发**：
   - 进入 `Beancount-Trans-Frontend/`
   - 运行 `npm install` 安装依赖
   - 运行 `npm run dev` 启动开发服务器
   - 前端开发服务器代理 API 请求到后端

3. **后端开发**：
   - 进入 `Beancount-Trans-Backend/`
   - 配置虚拟环境和依赖（pipenv 或 venv）
   - 配置 `.env` 文件（参考 `docs/ENV_CONFIG.md`）
   - 运行 `python manage.py runserver`

4. **Docker 开发**：
   - 在根目录运行 `docker compose up`
   - 访问 `http://localhost:38001/trans`

### 代码规范

- **后端**：遵循 `Beancount-Trans-Backend/.cursor/rules/` 中的规则
- **前端**：遵循 `Beancount-Trans-Frontend/.cursor/rules/` 中的规则
- **跨模块**：遵循本文件中的整体规范

### 测试

- **后端测试**：在 `Beancount-Trans-Backend/` 中运行 `pytest`
- **前端测试**：在 `Beancount-Trans-Frontend/` 中运行测试命令
- **集成测试**：使用 Docker Compose 启动完整环境进行测试

## CI/CD 流程

### 主仓库 CI

根目录 [`Jenkinsfile`](mdc:Jenkinsfile) 负责 Semantic Release，管理主仓库版本号。

### 子模块 CI

每个子模块有独立的 `Jenkinsfile`：
- **后端**：`Beancount-Trans-Backend/Jenkinsfile` - 运行测试、构建 Docker 镜像
- **前端**：`Beancount-Trans-Frontend/Jenkinsfile` - 构建静态文件、构建 Docker 镜像
- **文档**：`Beancount-Trans-Docs/Jenkinsfile` - 构建和部署文档站点

### 发布流程

1. 子模块独立发布（更新子模块版本）
2. 更新主仓库中的子模块引用
3. 主仓库 Semantic Release 自动创建 Git 标签和 Release

## 跨模块协作

### API 契约

- **接口定义**：后端在 DRF 中定义 API，使用 `drf-spectacular` 生成 OpenAPI 文档
- **类型定义**：前端在 `src/types/` 中定义与后端 API 对应的 TypeScript 类型
- **版本兼容**：API 变更时需要考虑向后兼容，使用版本号管理

### 数据流

1. **用户上传文件** → 前端选择 → 后端接收并存储
2. **提交解析任务** → 前端提交 → 后端创建 Celery 任务 → 前端轮询状态
3. **查看账本** → 前端请求 → 后端启动 Fava 容器 → 返回访问 URL

### 依赖关系

```
Frontend → Backend API → Database/Redis/MinIO
Backend → Celery Worker → File System/MinIO
Backend → Fava Container → Beancount-Trans-Assets/
```

## 文档规范

### 项目文档

- **用户文档**：`Beancount-Trans-Docs/docs/` - 面向最终用户的使用指南
- **API 文档**：由后端自动生成，部署后通过 `/api/redoc/` 访问OpenAPI文档
- **开发文档**：各子模块的 `README.md` 和 `docs/` 目录

### 文档更新

- 代码变更时同步更新相关文档
- API 变更时更新 OpenAPI 文档和前端类型定义
- 新功能发布时更新用户文档

## 版本管理

### 版本号格式

遵循 [Semantic Versioning](https://semver.org/)：
- **主版本号**：不兼容的 API 变更
- **次版本号**：向后兼容的功能新增
- **修订号**：向后兼容的问题修复

### 提交信息规范

项目使用 [Conventional Commits](https://www.conventionalcommits.org/) 规范，提交信息格式为：

```text
<type>(<scope>): <subject>

<body>

<footer>
```

#### 触发发布的提交类型

以下提交类型会触发 Semantic Release 自动发布：

- **`feat!` 或 `feat(<scope>)!`**：触发主版本号更新（MAJOR）- 破坏性变更
- **`feat` 或 `feat(<scope>)`**：触发次版本号更新（MINOR）- 新功能
- **`fix` 或 `fix(<scope>)`**：触发修订版本号更新（PATCH）- Bug 修复

示例：
```text
feat!: 添加破坏性变更的功能
feat(api)!: 移除旧API
feat: 添加新功能
feat(auth): 添加用户认证
fix: 修复bug
fix(login): 修复登录失败问题
```

#### 不触发发布的提交类型

以下提交类型不会触发发布，但会包含在 CHANGELOG 中：

- **`docs`**：文档更新
- **`style`**：代码风格调整（格式化、空格等）
- **`refactor`**：代码重构（不改变功能）
- **`perf`**：性能优化
- **`test`**：测试相关（添加或修改测试）
- **`chore`**：构建过程或辅助工具变动（包括依赖更新）

示例：
```text
docs: 更新API文档
docs(readme): 添加安装说明
style: 格式化代码
style(button): 调整按钮样式
refactor: 代码重构
refactor(utils): 优化工具函数
perf: 性能优化
perf(render): 优化渲染性能
test: 添加测试用例
test(login): 增加登录测试
chore: 构建过程或辅助工具变动
chore(deps): 更新依赖包
```

### 分支规范

- **主分支**：`main` - 用于生产环境，受 Semantic Release 保护
- **功能分支**：`feat/<feature-name>` - 新功能开发
- **修复分支**：`fix/<bug-name>` - Bug 修复
- **发布分支**：由 Semantic Release 自动管理

### 版本位置

- **后端**：`Beancount-Trans-Backend/pyproject.toml`、`requirements.txt`
- **前端**：`Beancount-Trans-Frontend/package.json`
- **主仓库**：通过 Semantic Release 管理，基于 Git 标签

### Semantic Release 发布流程

1. 在 `main` 分支提交符合规范的提交信息
2. Semantic Release 自动分析提交并确定版本号
3. 自动生成 CHANGELOG 和 Git 标签
4. 自动创建 GitHub Release

### 发布说明

每个版本更新应在 `CHANGELOG.md` 中记录变更内容（各子模块独立维护，由 Semantic Release 自动生成）。
